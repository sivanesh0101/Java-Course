# 8. Exception Handling in Java

## 1. What is Exception Handling?

An exception is an unexpected event or error that occurs during program execution and disrupts the normal flow of instructions.

Exception Handling is Java’s mechanism to handle such runtime errors gracefully — instead of crashing, it lets the program respond intelligently.

### Example (Without Handling)
```java
int a = 10, b = 0;
int result = a / b; // Runtime Error: ArithmeticException
System.out.println(result);
```

Output:
```
Exception in thread "main" java.lang.ArithmeticException: / by zero
```

---

## 2. Why We Need Exception Handling
 
- To handle runtime errors safely  
- To keep applications stable (especially in banking, e-commerce, etc.)  
- To log and track unexpected behavior  

---

## 3. Where We Use It in Real Life

- Banking apps: Handle “insufficient balance” or “network failure”  
- Web apps: Handle “file not found”, “API timeout”, “invalid input”  
- Enterprise systems: Prevent service crash when one operation fails  

---

## 4. How It Works (Core Components)

### try-catch-finally block

| Block | Purpose |
|--------|----------|
| `try` | Contains risky code that might throw an exception |
| `catch` | Handles the exception if it occurs |
| `finally` | Runs always — even if an exception occurs (used for cleanup) |


```java
public class TryCatchExample {
    public static void main(String[] args) {
        int a = 10 / 2; // ✅ no exception (safe division)
        System.out.println("Result: " + a);
        System.out.println("End of program.");
    }
}


```

### Example
```java
public class TryCatchExample {
    public static void main(String[] args) {
        try {
            int a = 10 / 0; // risky code
            System.out.println(a);
        } catch (ArithmeticException e) {
            System.out.println("Error: Cannot divide by zero.");
        } finally {
            System.out.println("End of program (finally block).");
        }
    }
}
```

Output:
```
Error: Cannot divide by zero.
End of program (finally block).
```

---




## 1) Types of Exceptions (Checked vs Unchecked)

**What**
- **Checked exceptions**: Predictable problems (files, network, database). The compiler **forces** you to handle or declare them.
- **Unchecked exceptions**: Programming/runtime errors (divide by zero, null pointer). The compiler **does not** force handling.

**Why**  
To separate “expected risks” (checked) from “bugs/misuse” (unchecked).

**Where**  
- Checked: File I/O, JDBC, network calls.  
- Unchecked: Logic mistakes, bad indexes, nulls.

**Examples**
```java
// Unchecked: ArithmeticException
int x = 10 / 0; // crash at runtime

// Checked: IOException (must handle or declare)
import java.io.FileReader;
void load() throws java.io.IOException {
    FileReader fr = new FileReader("config.txt"); // may not exist
}
```

---

## 2) try–catch–finally block

**What**  
A control structure to run risky code, handle failures, and always clean up.

**Why**  
Prevents crashes and ensures cleanup (closing files, releasing locks) even if errors occur.

**Where**  
File/database operations, parsing, network calls.

**Example**
```java
try {
    int result = 10 / 0;           // risky
    System.out.println(result);
} catch (ArithmeticException e) {
    System.out.println("Cannot divide by zero.");
} finally {
    System.out.println("Cleanup happens here (always runs).");
}
```

---

## 3) `throw` vs `throws`

**What**  
- **`throw`**: Actually *raise* an exception **now**.
- **`throws`**: *Declare* that a method might raise an exception; callers must handle or re-declare.

**Why**  
- `throw`: enforce business rules immediately.  
- `throws`: push responsibility to the caller.

**Where**  
- `throw`: input validation, business rule checks.  
- `throws`: methods that perform I/O or call other risky code.

**Examples**
```java
// throw: trigger now
void checkAge(int age) {
    if (age < 18) throw new IllegalArgumentException("Must be 18+");
}

// throws: announce possibility
import java.io.IOException;
void readData() throws IOException {
    // ... code that may cause IOException
}
```

---

## 4) Creating Custom Exceptions

**What**  
Your own exception class with a meaningful name.

**Why**  
Clearer error intent (e.g., `OutOfStockException`, `InsufficientBalanceException`).

**Where**  
Domain/business rules.

**Example (checked custom exception)**
```java
class InsufficientBalanceException extends Exception {
    public InsufficientBalanceException(String msg) { super(msg); }
}

class Bank {
    void withdraw(double balance, double amount) throws InsufficientBalanceException {
        if (amount > balance) throw new InsufficientBalanceException("Not enough funds");
        System.out.println("Withdraw successful");
    }
}
```

---

## 5) `try-with-resources`

**What**  
A `try` form that **auto-closes** resources (files, streams, DB connections) after use.

**Why**  
Avoids resource leaks and reduces boilerplate.

**Where**  
Whenever you open a closeable resource (`Closeable`/`AutoCloseable`).

**Example**
```java
import java.io.*;

try (BufferedReader br = new BufferedReader(new FileReader("notes.txt"))) {
    System.out.println(br.readLine());
} catch (IOException e) {
    System.out.println("Read failed: " + e.getMessage());
} // br auto-closed here
```

---

## Quick Reference

- **Checked** = expected risk → must handle/declare.  
- **Unchecked** = programmer/runtime error → fix code; optionally catch.  
- **try–catch–finally** = do → handle → always clean up.  
- **throw** = raise now; **throws** = may raise (caller decides).  
- **try-with-resources** = safe auto-close for files/streams/DB.

---

## Mini Practice

1) Wrap `int a = 10/0;` in try–catch and print a friendly message.  
2) Write a method `loadFile(String path)` that **throws** `IOException` and handle it in `main`.  
3) Create `OutOfStockException` (checked) and throw it if `stock <= 0`.  
4) Use `try-with-resources` to write `"Hello"` into `output.txt` with `FileWriter`.  
5) Validate `age`; if `< 13`, **throw** `IllegalArgumentException("Underage")`.