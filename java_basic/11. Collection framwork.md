# Java Collections Framework


---

## What is the Collections Framework?
A **toolkit of ready-made containers** to store and manage groups of items (names, emails, records). It provides common data structures and operations so you write **less code** with **fewer bugs**.

**Main families:**
- **List** — ordered items, duplicates allowed (`ArrayList`, `LinkedList`)
- **Set** — unique items, no duplicates (`HashSet`, `TreeSet`)
- **Map** — key → value lookup (`HashMap`)

> Think: List = ordered bag, Set = unique basket, Map = dictionary (word → meaning).

---

---

## 1) `ArrayList` — Resizable Array
**What:** Ordered list; access by index (0,1,2).  
**Why:** Fast reads by position; grows automatically.  
**Use cases:** Attendance list, shopping cart, playlist in order.

```java
import java.util.ArrayList;

public class DemoArrayList {
    public static void main(String[] args) {
        ArrayList<String> students = new ArrayList<>();
        students.add("Anu");
        students.add("Bala");
        students.add("Chitra");

        System.out.println(students.get(0)); // Anu
        students.remove("Bala");             // remove by value
        System.out.println(students.contains("Chitra")); // true

        for (String s : students) {
            System.out.println(s);
        }
    }
}
```

**Not ideal:** frequent insert/delete in the **middle** (slower).

---

## 2) `LinkedList` — Linked Nodes
**What:** List made of nodes connected together.  
**Why:** Efficient add/remove at **beginning or end**.  
**Use cases:** Recent pages history, queue of tasks, next/previous tracks.

```java
import java.util.LinkedList;

public class DemoLinkedList {
    public static void main(String[] args) {
        LinkedList<String> tasks = new LinkedList<>();
        tasks.addLast("Open tickets");      // add at end
        tasks.addLast("Fix bug #12");
        tasks.addFirst("Stand-up meeting"); // add at start

        System.out.println(tasks.removeFirst()); // Stand-up meeting
        System.out.println(tasks.removeLast());  // Fix bug #12
        System.out.println(tasks);               // [Open tickets]
    }
}
```

**Note:** Access by index (like `get(30)`) is slower than `ArrayList`.

---

## 3) `HashSet` — Unique Items (Fast)
**What:** No duplicates; no guaranteed order.  
**Why:** Keep only unique values with quick add/check.  
**Use cases:** Unique emails, unique course codes, unique tags.

```java
import java.util.HashSet;

public class DemoHashSet {
    public static void main(String[] args) {
        HashSet<String> emails = new HashSet<>();
        emails.add("a@x.com");
        emails.add("b@x.com");
        emails.add("a@x.com"); // duplicate ignored

        System.out.println(emails.contains("b@x.com")); // true
        System.out.println(emails.size());              // 2

        for (String e : emails) {
            System.out.println(e);
        }
    }
}
```

---

## 4) `TreeSet` — Unique **and Sorted**
**What:** Set that maintains **sorted** order.  
**Why:** Need uniqueness + alphabetical/numerical order.  
**Use cases:** Sorted unique student names, ranks, tags.

```java
import java.util.TreeSet;

public class DemoTreeSet {
    public static void main(String[] args) {
        TreeSet<String> names = new TreeSet<>();
        names.add("Kiran");
        names.add("Anu");
        names.add("Bala");
        names.add("Anu"); // duplicate ignored

        System.out.println(names);      // [Anu, Bala, Kiran] (sorted)
        System.out.println(names.first()); // smallest -> Anu
        System.out.println(names.last());  // largest  -> Kiran
    }
}
```

---

## 5) `HashMap<K, V>` — Key → Value Lookup
**What:** Dictionary where each **key** maps to a **value**.  
**Why:** Super fast lookup by key.  
**Use cases:** rollNo → name, username → profile, countryCode → countryName.

```java
import java.util.HashMap;

public class DemoHashMap {
    public static void main(String[] args) {
        HashMap<Integer, String> rollToName = new HashMap<>();
        rollToName.put(101, "Anu");
        rollToName.put(102, "Bala");
        rollToName.put(103, "Chitra");

        System.out.println(rollToName.get(102));        // Bala
        System.out.println(rollToName.containsKey(999)); // false

        // loop through entries
        for (var entry : rollToName.entrySet()) {
            System.out.println(entry.getKey() + " -> " + entry.getValue());
        }

        rollToName.remove(101); // delete by key
    }
}
```

---

## 6) Iteration — Enhanced For & Iterator
You often need to go through every item.

### Enhanced for (easy way)
```java
import java.util.ArrayList;

public class DemoEnhancedFor {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("A"); list.add("B"); list.add("C");

        for (String s : list) {
            System.out.println(s);
        }
    }
}
```

### Iterator (when removing while looping)
```java
import java.util.ArrayList;
import java.util.Iterator;

public class DemoIterator {
    public static void main(String[] args) {
        ArrayList<String> items = new ArrayList<>();
        items.add("pen");
        items.add("pencil");
        items.add("pen"); // duplicate

        Iterator<String> it = items.iterator();
        while (it.hasNext()) {
            String val = it.next();
            if (val.equals("pen")) {
                it.remove(); // safe removal during iteration
            }
        }
        System.out.println(items); // [pencil]
    }
}
```

---

## Beginner Use Cases (Pick the Right Collection)
- **Attendance list in order:** `ArrayList<String>`  
- **Playlist where you add/remove at ends a lot:** `LinkedList<String>`  
- **Unique course codes:** `HashSet<String>`  
- **Unique names but always sorted:** `TreeSet<String>`  
- **Find student by roll number:** `HashMap<Integer, String>`  

---

## Tiny Performance Intuition
- **ArrayList:** fast read by index; slower insert/delete in middle  
- **LinkedList:** good for add/remove at ends; slow random access  
- **HashSet/HashMap:** very fast add/find/remove; no order guarantee  
- **TreeSet:** sorted; a bit slower than `HashSet` due to ordering

---
